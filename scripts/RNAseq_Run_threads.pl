#!/usr/bin/perl

##    RNAseq_Run.pl
##       
##      Copyright 2011 Lin Wang <lw374@cornell.edu> -- Brutnell Lab  
##      Copyright 2011 > Vaughn <vaughn@iplantcollaborative.org> -- TACC
## 
##      Version 1.5 -- 06/15/2011
##      Version 1.6 -- 07/19/2011
##       
##    This program is free software; you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation; either version 2 of the License, or
##    (at your option) any later version.
##       
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
     
										
##  This script will use the modified SAM/BAM files produced by BWA and annotation   	
##  files to calculate exon coverages.This script was written based on a script originally
##  developed by Lalit Ponnala for the study of maize transcriptome (PMID:21037569) 							

=head1

Usage: RNAseq_Run_threads.pl -mis <allowed number of mismatches> -gap <allowed gap extension> -multi <allowed maximum alignments from a single read> -anno <folder containing outputs from RNAseq_PreRun_maizeV2.pl> -i <sequence reads in FASTQ format> -g <genome FASTA path> -l <read length> -w <one-half junction size>

=cut

use warnings;
use strict;
use File::Basename; 
use Getopt::Long;
use threads;
use Config;

$Config{useithreads} or die('Recompile Perl with threads to run this program.');   ## making sure Threads can be run

my $error = 2; 			## allowed number of mismatches (default: 2)
my $gap = 2;			## allowed gap extension (default: 2)
my $multi = 10;			## allowed maximum alignments from a single read (default: 10)
my $ejwidth= 25; 		## width of one side of the junction, total junction sequence length will be twice this much

my $seq;				## input reads in fastq format
my $genome;				## genome file in FASTA format (path can be included) 
my $annotation_folder;	## folder that contains all the processed annotation files generated by pre-run script
my $mini_overlap;		## defined as half of the read length, used to check if a read can be counted for a certain gene coverage or not
my $len;				## length of reads
my $help;				## help message
my $strand='both';		## the strand that reads will be aligned to (default: both strands)
my $maxpos;				## maximum coordinate of matching position of read along the junction sequence

# Explicit path to bwa
my $bwa_app = '/usr/local3/bin/bwa';

######--------------- Get options  ---------------######

GetOptions
( 					
  'mis:i'	=> \$error,				     
  'gap:i'	=> \$gap,				
  'multi:i'	=> \$multi,
  'anno:s'  => \$annotation_folder,
  'i:s'		=> \$seq,		    
  'g:s'  	=> \$genome,			          
  'l:i'  	=> \$len,
  'w:i'  	=> \$ejwidth,				   
  'help' 	=> \$help,				
);

######--------------- parsing options ---------------######

if ($help||!$genome||!$annotation_folder||!$len||!$seq){ &usage; exit(0);}				## show help message if input are not in correct format, or help option is used 
if ($annotation_folder !~ /\/$/){$annotation_folder = $annotation_folder.'/';} 			## fix annotation path if not properly given

$mini_overlap = $len/2;																	## minimal overlap as half of the read length
$maxpos=(2*$ejwidth)-$mini_overlap+1; 


######------------- Declare annotation variables -------------######

my $exon_coordinate; 		## exon coordinate file
my $transcript_coordinate; 	## transcript coordinate file
my $gene_coordinate; 		## gene coordinate file
my $trans_exon_junction;  	## transcript-exon mapping file
my $gene_trans; 			## gene-transcript mapping file
my $exon_juc_cord; 			## exon-junction coordinate file
my $exon_juc_seq; 			## exon-junction sequence file, used for junction alignments
my $nonecoding_coordinate;	## non-coding file



######----------- parsing the files in the annotation folder -----------######

opendir(ANNO_DIR, $annotation_folder) or die $!;  	## open the annotation folder
my $cs=0;  					  						## a simple CheckSum number for files in the annotation folder
my @anno_files= readdir(ANNO_DIR); 					## array of file names in the annotation folder

foreach my $anno_files (@anno_files) 
{
      if ($anno_files =~ /_exon\.csv$/) 	  			{ $exon_coordinate = $annotation_folder.$anno_files; $cs+=1;}
   elsif ($anno_files =~ /_transcript\.csv$/) 
		  {
	  	    if ($anno_files =~ /_gene_transcript\.csv$/){ $gene_trans = $annotation_folder.$anno_files; $cs+=1;}
		    else 										{ $transcript_coordinate = $annotation_folder.$anno_files; $cs+=1;}
		  }
   elsif ($anno_files =~ /_gene\.csv$/)					{ $gene_coordinate  = $annotation_folder.$anno_files; $cs+=1;}
   elsif ($anno_files =~ /_transcript_exon_junc\.csv$/) { $trans_exon_junction  = $annotation_folder.$anno_files; $cs+=1;}
   elsif ($anno_files =~ /_exon_junctions\.csv$/)		{ $exon_juc_cord = $annotation_folder.$anno_files; $cs+=1;}
   elsif ($anno_files =~ /_exon_junctions\.fa$/)		{ $exon_juc_seq = $annotation_folder.$anno_files; $cs+=1;}
   elsif ($anno_files =~ /_non_coding\.csv$/)			{ $nonecoding_coordinate = $annotation_folder.$anno_files; $cs+=1;}
   else  {next;}
} 
  
closedir (ANNO_DIR);  ## close folder handler
if (!($cs==8)) {print "\nIncomplete processed annotation files....\n"; exit;}			## safty check, make sure all file names with path are complete

my ($seq_name,$seq_path,$seq_suffix) = fileparse($seq,qr/\.[^.]*/);						## parse the file names for output files
my $exon_coverage_output_sense = $seq_path.$seq_name.'_exon_cov_sense.csv';				## sense exon coverage output file
my $exon_coverage_output_antisense = $seq_path.$seq_name.'_exon_cov_antisense.csv';		## antisense exon coverage output file
my $sorted_sam_file = $seq_path.$seq_name.$seq_suffix."_aligned_sorted\.sam";			## sorted sam file
my $sorted_bam_file = $seq_path.$seq_name.$seq_suffix."_aligned_sorted\.bam";			## sorted bam file for calculating exon coverage
my $nfile = $seq_path.$seq_name.'_unaligned'.$seq_suffix;								## fastq file for un-aligned reads
my $nfile_final = $seq_path.$seq_name.'_unaligned_final'.$seq_suffix;					## fastq file for final un-aligned reads after junction alignment
my $junc_sam_file = $seq_path.$seq_name.'_unaligned'.$seq_suffix."_aligned\.sam";		## sam file genenerated by junction alignments
my $junc_coverage_output_sense = $seq_path.$seq_name.'_junc_cov_sense.csv';				## sense junction coverage output file
my $junc_coverage_output_antisense = $seq_path.$seq_name.'_junc_cov_antisense.csv';		## antisense junction coverage output file
my $tfile_sense = $seq_path.$seq_name.'_tr_RPKM_sense.csv';								## final coverage/RPKM output for each transcripts
my $gfile_sense = $seq_path.$seq_name.'_gene_RPKM_sense.csv';							## final coverage/RPKM output for each gene model (most abundent transcripts)
my $tfile_antisense = $seq_path.$seq_name.'_tr_RPKM_antisense.csv';						## final coverage/RPKM output for each transcripts
my $gfile_antisense = $seq_path.$seq_name.'_gene_RPKM_antisense.csv';					## final coverage/RPKM output for each gene model (most abundent transcripts)
my $total_aligned_read = $seq_path.$seq_name.'_total_reads_aligned.csv';				## total number of reads aligned




######--------------- Aligning reads to the genome ----------------######

## return number of reads alinged to genome	
my $Greads = BWA_genome_align($error, $gap, $multi, $genome, $seq, $nfile);		


######-------------- Aligning reads to the junctions ---------------######

## adjustable parameters
my $error_junc = 1;
my $gap_junc = 1;
my $multi_junc =10;

## return number of reads alinged to junctions
my $Jreads = BWA_junc_align($error_junc, $gap_junc, $multi_junc, $exon_juc_seq, $nfile, $nfile_final); 
## sum up total number of aligned reads
my $total_reads_aligned = $Greads + $Jreads;

print "\nTotal number of reads aligned for junction and genome is $total_reads_aligned...\n";

open (TOTAL, ">$total_aligned_read") or die $!;
print TOTAL "$seq_name\t$total_reads_aligned\n";
close TOTAL;


######-------------- Calculating exon coverage ---------------######



my @threads;
my $t1 = threads->new(\&exon_coverage_sense, $sorted_bam_file,$exon_coordinate,$exon_coverage_output_sense,$mini_overlap);
my $t2 = threads->new(\&exon_coverage_antisense, $sorted_bam_file,$exon_coordinate,$exon_coverage_output_antisense,$mini_overlap);





#exon_coverage_sense($sorted_bam_file,$exon_coordinate,$exon_coverage_output_sense,$mini_overlap);
#exon_coverage_antisense($sorted_bam_file,$exon_coordinate,$exon_coverage_output_antisense,$mini_overlap);


######-------------- Calculating junction coverage ---------------######

my $t3 = threads->new(\&junction_coverage_sense, $junc_sam_file,$exon_juc_cord,$maxpos,$junc_coverage_output_sense,$strand);
my $t4 = threads->new(\&junction_coverage_antisense, $junc_sam_file,$exon_juc_cord,$maxpos,$junc_coverage_output_antisense,$strand);


$t1->join;
$t2->join;
$t3->join;
$t4->join;

#junction_coverage_sense($junc_sam_file,$exon_juc_cord,$maxpos,$junc_coverage_output_sense,$strand);
#junction_coverage_antisense($junc_sam_file,$exon_juc_cord,$maxpos,$junc_coverage_output_antisense,$strand);


#####-------------- Calculating transcript and gene RPKM ---------------######

my $t5 = threads->new(\&cal_tr_gene_RPKM, $exon_coverage_output_sense,$junc_coverage_output_sense,$tfile_sense,$gfile_sense,$trans_exon_junction,$gene_trans,$total_reads_aligned);
my $t6 = threads->new(\&cal_tr_gene_RPKM, $exon_coverage_output_antisense,$junc_coverage_output_antisense,$tfile_antisense,$gfile_antisense,$trans_exon_junction,$gene_trans,$total_reads_aligned);


$t5->join;
$t6->join;

#cal_tr_gene_RPKM($exon_coverage_output_sense,$junc_coverage_output_sense,$tfile_sense,$gfile_sense,$trans_exon_junction,$gene_trans,$total_reads_aligned); 
#cal_tr_gene_RPKM($exon_coverage_output_antisense,$junc_coverage_output_antisense,$tfile_antisense,$gfile_antisense,$trans_exon_junction,$gene_trans,$total_reads_aligned); 

exit;


###=====================================================================================================================###
###============================================  Sub-rountines from here on ============================================###
###=====================================================================================================================###


# ------------------------------------------------------------------------------------
# Give out usage information
# ------------------------------------------------------------------------------------
sub usage 
{
    print'    
    Program: RNAseq_Run.pl
    Version: 1.5 (06/15/2011)
    Contact: Lin Wang <lw374@cornell.edu>,  BIT Cornell, Brutnell Lab.

    This script requires BWA (alignment via Burrows-Wheeler transformation) to run, make sure it has been installed.
     
    The options are:
    
    -mis	: optional - allowed number of mismatches (default: 2)
    -gap	: optional - allowed gap extension (default: 1)    
    -multi	: optional - allowed maximum alignments from a single read (default: 25)
    -s		: optional - the strand that reads will be aligned to (default: both strands): sense/antisense
    -w		: optional - width of one side of the junction, total junction sequence length will be twice this much (default: 25)
    
    -anno	: folder that contains all the processed annotation files generated by pre-run script
    -i		: input reads in FASTQ format (path can be included) 
    -g		: genome file in FASTA format (path can be included) 
	-l		: read length
    
    -help	: print this help message'."\n\n";
}



# ------------------------------------------------------------------------------------
# BWA_genome_align: Align reads and modify the output SAM by adding a weight tag 
# ------------------------------------------------------------------------------------

sub BWA_genome_align
{
    if (scalar(@_)!=6) { die("There are not enough input parameters for BWA alignment"); }			## check number of inputs, if not enough.. quit
    my ($max_allowed_error,$gap_open,$max_multireads,$fasta_file, $seq_file, $nfile) = @_;			## take inputs 
    my ($genome_name,$gpath,) = fileparse($fasta_file, qr/\.[^.]*/);								## parse fasta input file name (genome or junction)
    my ($seq_name,$spath,) = fileparse($seq_file,qr/\.[^.]*/);										## parse reads input file name
    my $BWA_SAI_file = $seq_file.'.sai';															## define output .sai output file name
    my $BWA_SAM_file = $seq_file.'.sam';															## define output .sam output file name
	
	print "\n\n******** Aligning $seq_name against genome: $genome_name  ********\n\n";				
	if (-e $BWA_SAI_file) { system("rm -f $BWA_SAI_file"); } 									## If old .sai file exists, remove old sai file
	system("$bwa_app aln -n $max_allowed_error -o $gap_open $fasta_file $seq_file > $BWA_SAI_file");	## use BWA to align sequence file
	
	print "\n\n******** Converting $BWA_SAI_file into SAM alignment format  ********\n\n";	
	if (-e $BWA_SAM_file) { system("rm -f $BWA_SAM_file"); }									## If old .sam file exists, remove old sam file
	system("$bwa_app samse -n $max_multireads $fasta_file $BWA_SAI_file $seq_file > $BWA_SAM_file");	## converting .sai file into .sam file
	
	print "\n\n******** All output files have been saved in: $seq_path   ********\n";
	
	print "******** Now parsing the BWA-generated SAM alignments    ********\n";	
	my $ofile = $seq_file.'_aligned.sam';
	
	my %R=(); 			## hash to check for redundancy of reads in BWA-generated SAM file, and to also cound total read of aligned reads
	my %A=(); 			## hash to deal with aligned reads from BWA file
	my %N=(); 			## hash to count unaligned reads
	my $areads=0;		## number of reads that has alignments
	my $acount=0;		## integer to record how many alignments are written in the output modified sam/bam file
	my $linecount=0;	## variable to keep track of how many lines of SAM file have been processed

	open(OFILE,">$ofile") 	or die("Cannot open $ofile"); 			## create aligned SAM file output file
	open(NFILE,">$nfile") 	or die("Cannot open $nfile");			## create unaligned-reads fastq file as output
	open(SAM,$BWA_SAM_file) or die("Cannot open $BWA_SAM_file");	## open input BWA generated SAM file 
	  
	###/// processsing SAM file line by line ///####
	while (<SAM>) {
					my $line=$_; 						## read in SAM file line by line
					chomp($line); 						## getting rid of tailing blank space or new lines
					next if ($line=~/^\s*$/);			## skip empty blank lines
					$linecount++; 						## if ($linecount%100==0) { print "processing line $linecount\n"; last; };
						
					if ($line=~/^\@/) {print OFILE $line."\n"; next;} 		## simply print headers in the aligned SAM output file then go to next loop/line
					my @elems=split("\t",$line);							## if it is not header, split line by tab
												
					#### These next two line of codes are to insure there is no redundancy in aligned FASTq read name ($elems[0]) ####
					if (exists $R{$elems[0]}) { die("read name redundancy detected in $BWA_SAM_file : $elems[0]\n"); } 
					else {$R{$elems[0]}=1;}
								  
					###//// processing lines that does not show any alignments ////###
						
					if (scalar(@elems)<=11) { 
						print NFILE '@'.$elems[0]."\n".$elems[9]."\n".'+'.$elems[0]."\n".$elems[10]."\n"; $N{$elems[0]}=1; next;
						}
					if (($elems[1]!=0)&&($elems[1]!=16)) { # 0 and 16 are the only flag codes that indicate properly mapped single-end reads, as per samtools flag codes
						 print NFILE '@'.$elems[0]."\n".$elems[9]."\n".'+'.$elems[0]."\n".$elems[10]."\n"; $N{$elems[0]}=1; next;
						}
											
					###//// processing lines that does show alignment, basically what's left from previous filtering step ////###
					if ($elems[3]<0) { die("negative value found for best alignment\n$line\n\n"); } ## Safty check: if mapped position is negative, quit... 
					$A{$elems[0]}=1; 								## use to count total number of reads that have alignments
					my $numalign=0; 								## number of multiple aligned location
					my $XAtag='';									## declare XA tag string variable
						
					####//// lopping through the X tags...////###
					for (my $j=11; $j<scalar(@elems); $j++) {
											if ($elems[$j]=~/X0\:\S\:(\d+)/) { $numalign+=$1; }  ## count number of best hits
											if ($elems[$j]=~/X1\:\S\:(\d+)/) { $numalign+=$1; }  ## also count number of suboptimal hits
											if ($elems[$j]=~/XA\:\S\:(\S+)/) { $XAtag=$1; }      ## record alternative hits
										}
					if ($numalign==0) { die("unable to decide weight:\n$line\n"); } ## another safty check in case the two filters didn't work and some non-alignment went through					
					next if (($numalign>1)&&($XAtag eq '')); ## skip when there are too many alignments and XAtag is not reported 
					if (($numalign==1)&&($XAtag ne '')){ die("XA tag not found when numalign=1\n");} ## another check to ensure SAM file integrity

					$areads++; 							## reads with alignments
					my $weight=1/$numalign; 			## calculating weight - defined as (1/ number of alignments)
					$acount++; 							## number of alignment that will be written
					my $thisacount=1;
					print OFILE join("\t",@elems[0..10])."\tXW:f:$weight\n";  	## modify SAM file by adding weight (XW tag) at the end
					my @aligns=split(";",$XAtag); 								## splitting XA tags (alternative alignments) generated by BWA
						

					####//// following loop put all the alignment in the sam file and give them weight tag at the end... these are the suboptimal reads from BWA
					foreach (@aligns) {
										$_=~/(\S+)\,([+-])(\d+)\,(\S+)\,/; 
										my $strand=0;
										if ($2 eq '-'){$strand=16;}   ## determine strandness
										$acount++; 
										$thisacount++;
										print OFILE $elems[0]."\t".$strand."\t".$1."\t".$3."\t".$elems[4]."\t".$4."\t".join("\t",@elems[6..10])."\tXW:f:$weight\n";
										}
						
					if ($numalign!=$thisacount) { print "\nX0+X1=$numalign, reported alignments = $thisacount:\n$line\n"; } ## print out problems if the numbers of suboptimal read number does not match
				 }
	  close(SAM);
	  close(NFILE);
	  close(OFILE);
	  my $reads=scalar(keys %R); 	
	  my $Nreads=scalar(keys %N); 	
	  my $Areads=scalar(keys %A); 	
	  
	  #print "number of alignments written = $acount\n";
	  #return ($reads,$Nreads,$Areads,$areads,$acount);
	   
	  ### print out report on screen...
		
	  print "\n---- Alignment summary for $seq_name ----\n\n  number of reads = $reads\n  number of unaligned reads = $Nreads (".sprintf("%3.2f",100*($Nreads/$reads))." percent of total)\n  number of reads with alignment(s) reported = $Areads (".sprintf("%3.2f",100*($Areads/$reads))." percent of total)\n  number of reads with alignment(s) written (some suppressed by maximal alignments allowed) = $areads (".sprintf("%3.2f",100*($areads/$reads))." percent of total)\n  number of alignments written = $acount\n\n";
      
      
      
	  # clean up
	  undef %R; undef %A; undef %N;


	  print "\n---- Now converting modified SAM file to BAM format, and then sort and index the bam file ----\n\n";
	  
	  my $ofile_bam = $seq_file.'_aligned.bam';
	  my $ofile_bam_sorted = $seq_file.'_aligned_sorted';
	  my $ofile_bam_2index = $seq_file.'_aligned_sorted.bam';
	  
	  system("samtools view -bS -o $ofile_bam $ofile"); 	## convert SAM into BAM file
	  system("samtools sort $ofile_bam $ofile_bam_sorted"); ## sort converted BAM file
      system("samtools index $ofile_bam_2index"); 			## index sorted BAM file
      
      ## remove redundant files
                 
      system("rm $ofile_bam");
      system("rm $BWA_SAM_file");
	  system("rm $BWA_SAI_file");
      
      return $areads;

 }



# ------------------------------------------------------------------------------------
# BWA_genome_align: Align reads and modify the output SAM by adding a weight tag 
# ------------------------------------------------------------------------------------

sub BWA_junc_align
{
    if (scalar(@_)!=6) { die("There are not enough input parameters for BWA alignment"); }			## check number of inputs, if not enough.. quit
    my ($max_allowed_error,$gap_open,$max_multireads,$fasta_file, $seq_file, $nfile) = @_;			## take inputs 
    my ($genome_name,$gpath,) = fileparse($fasta_file, qr/\.[^.]*/);								## parse fasta input file name (genome or junction)
    my ($seq_name,$spath,) = fileparse($seq_file,qr/\.[^.]*/);										## parse reads input file name
    my $BWA_SAI_file = $seq_file.'.sai';															## define output .sai output file name
    my $BWA_SAM_file = $seq_file.'.sam';															## define output .sam output file name
	
	print "\n\n******** Aligning $seq_name against genome: $genome_name  ********\n\n";				
	if (-e $BWA_SAI_file) { system("rm -f $BWA_SAI_file"); } 									## If old .sai file exists, remove old sai file
	system("$bwa_app aln -n $max_allowed_error -o $gap_open $fasta_file $seq_file > $BWA_SAI_file");	## use BWA to align sequence file
	
	print "\n\n******** Converting $BWA_SAI_file into SAM alignment format  ********\n\n";	
	if (-e $BWA_SAM_file) { system("rm -f $BWA_SAM_file"); }									## If old .sam file exists, remove old sam file
	system("$bwa_app samse -n $max_multireads $fasta_file $BWA_SAI_file $seq_file > $BWA_SAM_file");	## converting .sai file into .sam file
	
	print "\n\n******** All output files have been saved in: $seq_path   ********\n";
	
	print "******** Now parsing the BWA-generated SAM alignments    ********\n";	
	my $ofile = $seq_file.'_aligned.sam';
	
	my %R=(); 			## hash to check for redundancy of reads in BWA-generated SAM file, and to also cound total read of aligned reads
	my %A=(); 			## hash to deal with aligned reads from BWA file
	my %N=(); 			## hash to count unaligned reads
	my $areads=0;		## number of reads that has alignments
	my $acount=0;		## integer to record how many alignments are written in the output modified sam/bam file
	my $linecount=0;	## variable to keep track of how many lines of SAM file have been processed

	open(OFILE,">$ofile") 	or die("Cannot open $ofile"); 			## create aligned SAM file output file
	open(NFILE,">$nfile") 	or die("Cannot open $nfile");			## create unaligned-reads fastq file as output
	open(SAM,$BWA_SAM_file) or die("Cannot open $BWA_SAM_file");	## open input BWA generated SAM file 
	  
	###/// processsing SAM file line by line ///####
	while (<SAM>) {
					my $line=$_; 						## read in SAM file line by line
					chomp($line); 						## getting rid of tailing blank space or new lines
					next if ($line=~/^\s*$/);			## skip empty blank lines
					$linecount++; 						## if ($linecount%100==0) { print "processing line $linecount\n"; last; };
						
					if ($line=~/^\@/) {print OFILE $line."\n"; next;} 		## simply print headers in the aligned SAM output file then go to next loop/line
					my @elems=split("\t",$line);							## if it is not header, split line by tab
												
					#### These next two line of codes are to insure there is no redundancy in aligned FASTq read name ($elems[0]) ####
					if (exists $R{$elems[0]}) { die("read name redundancy detected in $BWA_SAM_file : $elems[0]\n"); } 
					else {$R{$elems[0]}=1;}
					
 					     
						

					###//// processing lines that does not show any alignments ////###
						
					if (scalar(@elems)<=11) { 
						print NFILE '@'.$elems[0]."\n".$elems[9]."\n".'+'.$elems[0]."\n".$elems[10]."\n"; $N{$elems[0]}=1; next;
						}
					if (($elems[1]!=0)&&($elems[1]!=16)) { # 0 and 16 are the only flag codes that indicate properly mapped single-end reads, as per samtools flag codes
						 print NFILE '@'.$elems[0]."\n".$elems[9]."\n".'+'.$elems[0]."\n".$elems[10]."\n"; $N{$elems[0]}=1; next;
						}
						
					###//// processing lines that does show alignment, basically what's left from previous filtering step ////###
					if ($elems[3]<0) { die("negative value found for best alignment\n$line\n\n"); } ## Safty check: if mapped position is negative, quit... 
					$A{$elems[0]}=1; 								## use to count total number of reads that have alignments
					my $numalign=0; 								## number of multiple aligned location
					my $XAtag='';									## declare XA tag string variable
						
					####//// lopping through the X tags...////###
					for (my $j=11; $j<scalar(@elems); $j++) {
											if ($elems[$j]=~/X0\:\S\:(\d+)/) { $numalign+=$1; }  ## count number of best hits
											if ($elems[$j]=~/X1\:\S\:(\d+)/) { $numalign+=$1; }  ## also count number of suboptimal hits
											if ($elems[$j]=~/XA\:\S\:(\S+)/) { $XAtag=$1; }      ## record alternative hits
										}
					if ($numalign==0) { die("unable to decide weight:\n$line\n"); } ## another safty check in case the two filters didn't work and some non-alignment went through					
					next if (($numalign>1)&&($XAtag eq '')); ## skip when there are too many alignments and XAtag is not reported 
					if (($numalign==1)&&($XAtag ne '')){ die("XA tag not found when numalign=1\n");} ## another check to ensure SAM file integrity

					$areads++; 							## reads with alignments
					my $weight=1/$numalign; 			## calculating weight - defined as (1/ number of alignments)
					$acount++; 							## number of alignment that will be written
					my $thisacount=1;
					print OFILE join("\t",@elems[0..10])."\tXW:f:$weight\n";  	## modify SAM file by adding weight (XW tag) at the end
					my @aligns=split(";",$XAtag); 								## splitting XA tags (alternative alignments) generated by BWA
						

					####//// following loop put all the alignment in the sam file and give them weight tag at the end... these are the suboptimal reads from BWA
					foreach (@aligns) {
										$_=~/(\S+)\,([+-])(\d+)\,(\S+)\,/; 
										my $strand=0;
										if ($2 eq '-'){$strand=16;}   ## determine strandness
										$acount++; 
										$thisacount++;
										print OFILE $elems[0]."\t".$strand."\t".$1."\t".$3."\t".$elems[4]."\t".$4."\t".join("\t",@elems[6..10])."\tXW:f:$weight\n";
										}
						
					if ($numalign!=$thisacount) { print "\nX0+X1=$numalign, reported alignments = $thisacount:\n$line\n"; } ## print out problems if the numbers of suboptimal read number does not match
				 }
	  close(SAM);
	  close(NFILE);
	  close(OFILE);
	  my $reads=scalar(keys %R); 	
	  my $Nreads=scalar(keys %N); 	
	  my $Areads=scalar(keys %A); 	
	  
	  #print "number of alignments written = $acount\n";
	  #return ($reads,$Nreads,$Areads,$areads,$acount);
	   
	  ### print out report on screen...
		
	  print "\n---- Alignment summary for $seq_name ----\n\n  number of reads = $reads\n  number of unaligned reads = $Nreads (".sprintf("%3.2f",100*($Nreads/$reads))." percent of total)\n  number of reads with alignment(s) reported = $Areads (".sprintf("%3.2f",100*($Areads/$reads))." percent of total)\n  number of reads with alignment(s) written (some suppressed by maximal alignments allowed) = $areads (".sprintf("%3.2f",100*($areads/$reads))." percent of total)\n  number of alignments written = $acount\n\n";
	  # clean up
	  undef %R; undef %A; undef %N;
	  system("rm $BWA_SAM_file");
	  system("rm $BWA_SAI_file");
	  
	  return $areads;

 }
 
# ------------------------------------------------------------------------------------
# exon_coverage: calculate coverage for exon alignments
# ------------------------------------------------------------------------------------

sub exon_coverage_sense {
 
 if (scalar(@_)!=4) { die("Incorret number of input files for exon coverage calculaton..."); }	
 my ($file,$efile,$ofile,$minoverlap)=@_;	
 
 print "\nCalculating sense exon coverage .....\n";						
 my %E=();													## initiate hash for exon and its weight
 open(OFILE,">$ofile") or die $!;							## create output file, or die
 print OFILE "EXON\tCHR\tSTART\tSTOP\tSTRAND\tCOVERAGE\n";	## print out header line in output file
 open(EFILE,$efile) or die("Cannot open $efile");			## open exon coordinate file, or die
 my $linecount=0;											## initate row count for SAM file
	  

 ##### ----- loop through the exon coordinate file ---- #####
 while (<EFILE>) 
	{
		my $line=$_; 												## read in each line
		chomp($line); 												## chomp read line
		next if ($line=~/^\s*$/); 									## skip empty line
		$linecount++; 												## count number of rows that have been processed
		if ($linecount%100000==0) { print "Senese: line $linecount\n"; }	## report progress every 100000 rows processed
		my ($exon,$echr,$estart,$estop,$estrand)=split("\t",$line); ## read in information divided by tab from modifed SAM
		my $etag=$echr."\t".$estart."\t".$estop."\t".$estrand;		## create a varible $etag that stores all information for the exon except for the exon name
		
		if (exists $E{$etag}) 
		{print OFILE $exon."\t".$etag."\t".$E{$etag}."\n"; next; }	## if the weight score already exist for the exon, print it out to output and go to the next record
		
		my $estartp=$estart+$minoverlap;							## define exon start overlap postion  
		my $estopm=$estop-$minoverlap;								## define exon stop overlap postion
		
		if ($estartp>$estopm)										## if the minimal overlap is bigger than half the size of exon 
		{$estartp=int($estart+(($estop-$estart)/2));$estopm=$estartp;}  ## use half exon as the minimal overlap
		
		my $cmdstr='samtools view '.$file.' '.$echr.':'.$estartp.'-'.$estopm;	## give "samtools view" commend to a string variable
		my $result=`$cmdstr`; 													## excute "samtools view" to extract alignment results
		my $weight=0;															## initate weight variable
														
       
       ##### --- if there are alignments, loop through them ---- #####
       
	   if ($result!~/^\s*$/){														## make sure the there are alignments
	        my @alines=split("\n",$result); 										## alignments are sparated in different rows
			foreach my $aline (@alines){ 											## loop through each alignment record
			    if ($aline=~/invalid/) { die("invalid region:\n$cmdstr\n"); } 		## save check just in case of invalid region
				my @pieces=split("\t",$aline);										## split each row of alignment extracted
				if (($pieces[1]!=0)&&($pieces[1]!=16)){ 							## There has to be alignment... or $pieces[1] is either 0 or 16..
				 die("invalid flag code reported in modified sam file: $file\n");}	## if not.. quit script and give error messages...
														
				if ((($estrand eq '+')&&($pieces[1]==16))||(($estrand eq '-')&&($pieces[1]==0))){next;}   ## ignore anti-sense alignments!
	
				my $xw=pop(@pieces); 											## pop weight tag
				if ($xw=~/^XW\:f\:([\d\.]+)/) {$weight+=$1;} 					## add up weight
				else { die("last element does not have XW tag:\n$aline\n"); }	## exit if no weight tag
			  }
		 }
			
		print OFILE $exon."\t".$etag."\t".$weight."\n"; ## output weight
		$E{$etag}=$weight; ## generate a hash keep track of exon-location (key) with its weight sum as value
	}
 
  close(EFILE);  ## close input file
  close(OFILE);  ## close output file
  
  # clean up
  undef %E;
}


# ------------------------------------------------------------------------------------
# exon_coverage: calculate coverage for exon alignments
# ------------------------------------------------------------------------------------

sub exon_coverage_antisense {
 
 if (scalar(@_)!=4) { die("Incorret number of input files for exon coverage calculaton..."); }	
 my ($file,$efile,$ofile,$minoverlap)=@_;	
 
 print "\nCalculating antisense exon coverage .....\n";						
 my %E=();													## initiate hash for exon and its weight
 open(OFILE,">$ofile") or die $!;			## create output file, or die
 print OFILE "EXON\tCHR\tSTART\tSTOP\tSTRAND\tCOVERAGE\n";	## print out header line in output file
 open(EFILE,$efile) or die("Cannot open $efile");			## open exon coordinate file, or die
 my $linecount=0;											## initate row count for SAM file
	  

 ##### ----- loop through the exon coordinate file ---- #####
 while (<EFILE>) 
	{
		my $line=$_; 												## read in each line
		chomp($line); 												## chomp read line
		next if ($line=~/^\s*$/); 									## skip empty line
		$linecount++; 												## count number of rows that have been processed
		if ($linecount%100000==0) { print "Antisense: line $linecount\n"; }	## report progress every 100000 rows processed
		my ($exon,$echr,$estart,$estop,$estrand)=split("\t",$line); ## read in information divided by tab from modifed SAM
		my $etag=$echr."\t".$estart."\t".$estop."\t".$estrand;		## create a varible $etag that stores all information for the exon except for the exon name
		
		if (exists $E{$etag}) 
		{print OFILE $exon."\t".$etag."\t".$E{$etag}."\n"; next; }	## if the weight score already exist for the exon, print it out to output and go to the next record
		
		my $estartp=$estart+$minoverlap;							## define exon start overlap postion  
		my $estopm=$estop-$minoverlap;								## define exon stop overlap postion
		
		if ($estartp>$estopm)										## if the minimal overlap is bigger than half the size of exon 
		{$estartp=int($estart+(($estop-$estart)/2));$estopm=$estartp;}  ## use half exon as the minimal overlap
		
		my $cmdstr='samtools view '.$file.' '.$echr.':'.$estartp.'-'.$estopm;	## give "samtools view" commend to a string variable
		my $result=`$cmdstr`; 													## excute "samtools view" to extract alignment results
		my $weight=0;															## initate weight variable
														
       
       ##### --- if there are alignments, loop through them ---- #####
       
	   if ($result!~/^\s*$/){														## make sure the there are alignments
	        my @alines=split("\n",$result); 										## alignments are sparated in different rows
			foreach my $aline (@alines){ 											## loop through each alignment record
			    if ($aline=~/invalid/) { die("invalid region:\n$cmdstr\n"); } 		## save check just in case of invalid region
				my @pieces=split("\t",$aline);										## split each row of alignment extracted
				if (($pieces[1]!=0)&&($pieces[1]!=16)){ 							## There has to be alignment... or $pieces[1] is either 0 or 16..
				 die("invalid flag code reported in modified sam file: $file\n");}	## if not.. quit script and give error messages...
				
				if ( (($estrand eq '+')&&($pieces[1]==0)) || (($estrand eq '-')&&($pieces[1]==16)) )  { next; }## ignore sense alignments!
	
				my $xw=pop(@pieces); 											## pop weight tag
				if ($xw=~/^XW\:f\:([\d\.]+)/) {$weight+=$1;} 					## add up weight
				else { die("last element does not have XW tag:\n$aline\n"); }	## exit if no weight tag
			  }
		 }
			
		print OFILE $exon."\t".$etag."\t".$weight."\n"; ## output weight
		$E{$etag}=$weight; ## generate a hash keep track of exon-location (key) with its weight sum as value
	}
 
  close(EFILE);  ## close input file
  close(OFILE);  ## close output file
  
  # clean up
  undef %E;
}

# ----------------------------------------------------------------------------
# sub-routine junction_coverage: Sum the alignment-weights for each junction
# ----------------------------------------------------------------------------
sub junction_coverage_sense {
	
 # INPUT:
 # $file = modified SAM file containing only the aligned reads
 # $ejcfile = exon-junction coordinate file
 # $maxpos = maximum coordinate of matching position of read along the junction sequence
 # $strand_info = strand for which to count reads

 # OUTPUT:
 # $ofile = junction coverage file
 
 if (scalar(@_)!=5) {die("incorrect number of inputs to calc_junc_coverage\n");} 
 my ($file,$ejcfile,$maxpos,$ofile,$strand_info)=@_;
 print "\nCalculate sense junction coverage.....\n";
 
 my $linecount=0;
 my %jstrand=(); ## define a hash for junction strandness
 
  
 open(FILE,$ejcfile) or die("Cannot open $ejcfile");  ## open exon junction files, or die
  
 while (<FILE>) {
					chomp; next if ($_=~/^\s*$/); 	## read line by line, clean up and skip empty lines
					my @elems=split("\t",$_); 		## tab separate the elements in each line
					$jstrand{$elems[0]}=$elems[4]; 	## store the junction strandness in the hash
				}
 close(FILE);

 my %jcov=();  ## define a hash for junction coverage
  
 open(FILE,$file) or die("Cannot open $file");  ## open exon junction alignment file, or die
  
 while (<FILE>) {
	chomp;
	++$linecount;
	if ($linecount%100000==0) { print "Junction sense: line $linecount\n"; } 
	next if ($_=~/^\s*$/);
	next if ($_=~/^\@/);
	my @elems=split("\t",$_); 
	if (($elems[1]!=0)&&($elems[1]!=16)) { die("invalid flag code reported in modified sam file: $file\n"); }
	
			
	if ((($jstrand{$elems[2]} eq '+')&&($elems[1]==16))||(($jstrand{$elems[2]} eq '-')&&($elems[1]==0))){next;} ## ignore anti-sense alignments!
		
		
			
    if ($elems[3]>$maxpos) { next; } # skip if minimum portion of read does not overlap with junction
	
	my $xw=pop(@elems); ## pop the weight tag
					
	if ($xw=~/^XW\:f\:([\d\.]+)/) {
									my $weight=$1; 													## capture weight string
									if (exists $jcov{$elems[2]}) { $jcov{$elems[2]}+=$weight; }  	## if previous junction has been analyzed, sum up the weight
									else { $jcov{$elems[2]}=$weight; }  							## if not, then just give the weight it has right now
								  }
	else { die("last element does not have XW tag:\n$_\n"); }} ## safty check, all record should have the weight tag
    
	close(FILE);  ## close input file
  
	open(OFILE,">$ofile") or die("Cannot open $ofile"); ## create output file, or die
  
	foreach my $junc (keys %jcov) { print OFILE $junc."\t".$jcov{$junc}."\n"; }  ## for each junction, print out the junction coverage (summed weight)
  
	close(OFILE); ## close output file

	# clean up
	undef %jcov;
}


# ----------------------------------------------------------------------------
# sub-routine junction_coverage: Sum the alignment-weights for each junction
# ----------------------------------------------------------------------------
sub junction_coverage_antisense {
	
 # INPUT:
 # $file = modified SAM file containing only the aligned reads
 # $ejcfile = exon-junction coordinate file
 # $maxpos = maximum coordinate of matching position of read along the junction sequence
 # $strand_info = strand for which to count reads

 # OUTPUT:
 # $ofile = junction coverage file
 
 if (scalar(@_)!=5) {die("incorrect number of inputs to calc_junc_coverage\n");} 
 my ($file,$ejcfile,$maxpos,$ofile,$strand_info)=@_;
 print "\nCalculate sense junction coverage.....\n";
 
 my $linecount=0;
 my %jstrand=(); ## define a hash for junction strandness
 
  
 open(FILE,$ejcfile) or die("Cannot open $ejcfile");  ## open exon junction files, or die
  
 while (<FILE>) {
					chomp; next if ($_=~/^\s*$/); 	## read line by line, clean up and skip empty lines
					my @elems=split("\t",$_); 		## tab separate the elements in each line
					$jstrand{$elems[0]}=$elems[4]; 	## store the junction strandness in the hash
				}
 close(FILE);

 my %jcov=();  ## define a hash for junction coverage
  
 open(FILE,$file) or die("Cannot open $file");  ## open exon junction alignment file, or die
  
 while (<FILE>) {
	chomp;
	++$linecount;
	if ($linecount%100000==0) { print "Junction antisense: line $linecount\n"; } 
	next if ($_=~/^\s*$/);
	next if ($_=~/^\@/);
	my @elems=split("\t",$_); 
	if (($elems[1]!=0)&&($elems[1]!=16)) { die("invalid flag code reported in modified sam file: $file\n"); }

	if ((($jstrand{$elems[2]} eq '+')&&($elems[1]==0))||(($jstrand{$elems[2]} eq '-')&&($elems[1]==16))){next;} ## ignore sense alignments! 		
			
    if ($elems[3]>$maxpos) { next; } # skip if minimum portion of read does not overlap with junction
	
	my $xw=pop(@elems); ## pop the weight tag
					
	if ($xw=~/^XW\:f\:([\d\.]+)/) {
									my $weight=$1; 													## capture weight string
									if (exists $jcov{$elems[2]}) { $jcov{$elems[2]}+=$weight; }  	## if previous junction has been analyzed, sum up the weight
									else { $jcov{$elems[2]}=$weight; }  							## if not, then just give the weight it has right now
								  }
	else { die("last element does not have XW tag:\n$_\n"); }} ## safty check, all record should have the weight tag
    
	close(FILE);  ## close input file
  
	open(OFILE,">$ofile") or die("Cannot open $ofile"); ## create output file, or die
  
	foreach my $junc (keys %jcov) { print OFILE $junc."\t".$jcov{$junc}."\n"; }  ## for each junction, print out the junction coverage (summed weight)
  
	close(OFILE); ## close output file

	# clean up
	undef %jcov;
}


sub cal_tr_gene_RPKM {

# --------------------------------------------------------------
# Calculate transcript and gene coverage
# --------------------------------------------------------------
# INPUTS:
# $efile = exon coverage file (exon chr start stop strand coverage) 
# $jfile = junction coverage file (junction coverage)
# $tefile = transcript-exon-junction mapping file (transcript length exons junctions)
# $gtfile = gene-transcript mapping file (gene transcripts)
# $mreads = number of mapped reads from genome + junctions (no overlaps exist since genome-unaligned reads are aligned against junctions independently)
# OUTPUTS:
# $tfile = transcript coverage file
# $gfile = gene coverage file

  if (scalar(@_)!=7) { die("incorrect number of inputs to calculate gene coverage and RPKM...\n"); }
  my ($efile,$jfile,$tfile,$gfile,$tefile,$gtfile,$mreads)=@_;


  my %exoncov=();  	## hash to process exon coverage
  
  open(EFILE,$efile) or die("Cannot open $efile");
  while (<EFILE>) {
    chomp; next if ($_=~/^\s*$/);
    my ($exon,$chr,$start,$stop,$strand,$cov)=split("\t",$_);
    $exoncov{$exon}=$cov;
  }
  close(EFILE);

  my %jcov=();	## hash to process junction coverage
  	
  open(JFILE,$jfile) or die("Cannot open $jfile");
  while (<JFILE>) {
    chomp; next if ($_=~/^\s*$/);
    my ($junc,$cov)=split("\t",$_);
    $jcov{$junc}=$cov;
  }
  close(JFILE);

  my %tcov=(); 	## transcript coverage
  my %trpkm=();	## transcript RPKM 
  my %tlen=();	## transcript length
  
  open(OFILE,">$tfile") or die("Cannot open $tfile");
  print OFILE "TRANSCRIPT\tLENGTH\tRPKM\tCOVERAGE\n";  ## print header for transcript coverage file
  
  open(FILE,$tefile) or die("Cannot open $tefile");
  while (<FILE>) {
    chomp; next if ($_=~/^\s*$/);
    my @elems=split("\t",$_);
    if (exists $tcov{$elems[0]}) { die("transcript coverage already exists for $elems[0]\n");}
    
    #### add up the exon-coverages first
    my @exons=split(",",$elems[2]); 
    my $totalcov=0;
    foreach my $exon (@exons) { $totalcov+=$exoncov{$exon}; }
    
    #### add the junction-coverages, if they exist
    if (scalar(@elems)==4) {
      my @juncs=split(",",$elems[3]);
      foreach my $junc (@juncs) {
        if (exists $jcov{$junc}) {$totalcov+=$jcov{$junc};}
      }
    }
    
    my $rpkm=$totalcov/(($elems[1]/1000)*($mreads/1000000));
    print OFILE $elems[0]."\t".$elems[1]."\t".$rpkm."\t".$totalcov."\n";
    
    $tcov{$elems[0]}=$totalcov; 
    $trpkm{$elems[0]}=$rpkm; 
    $tlen{$elems[0]}=$elems[1];
  }
  close(FILE);
  close(OFILE);

  # clean-up unwanted hashes
  undef %exoncov; undef %jcov;

  my @g_name=(); 
  my @g_tr=(); 
  my @g_len=(); 
  my @g_rpkm=(); 
  my @g_cov=();
  
  open(FILE,$gtfile) or die("Cannot open $gtfile");
  while (<FILE>) {
    chomp; next if ($_=~/^\s*$/);
    my @elems=split("\t",$_); 
    my @T=split(",",$elems[1]);
    my @C=(); 
    my @R=(); 
    my @L=();
    for (my $j=0; $j<scalar(@T); $j++) { push(@C,$tcov{$T[$j]}); push(@R,$trpkm{$T[$j]}); push(@L,$tlen{$T[$j]}); }
    my ($sa,$I)=numsortdescend(@R); @R=@$sa; @T=putarrayinorder(\@T,$I); @C=putarrayinorder(\@C,$I); @L=putarrayinorder(\@L,$I);
    my $tr=shift(@T); my $rpkm=shift(@R); my $cov=shift(@C); my $len=shift(@L);
    push(@g_name,$elems[0]); push(@g_tr,$tr); push(@g_len,$len); push(@g_rpkm,$rpkm); push(@g_cov,$cov);
  }
  close(FILE);

  # sort in decreasing order of rpkm
  my ($sa,$I)=numsortdescend(@g_rpkm); @g_rpkm=@$sa; @g_name=putarrayinorder(\@g_name,$I); @g_len=putarrayinorder(\@g_len,$I); @g_tr=putarrayinorder(\@g_tr,$I); @g_cov=putarrayinorder(\@g_cov,$I);

  open(OFILE,">$gfile") or die("Cannot open $gfile");
  print OFILE "GENE\tTRANSCRIPT\tLENGTH\tRPKM\tCOVERAGE\n";
  for (my $i=0; $i<scalar(@g_name); $i++) { print OFILE $g_name[$i]."\t".$g_tr[$i]."\t".$g_len[$i]."\t".$g_rpkm[$i]."\t".$g_cov[$i]."\n"; }
  close(OFILE);

  # clean up
  undef %tcov; undef %trpkm; undef %tlen; 
  undef @g_name; undef @g_tr; undef @g_len; undef @g_rpkm; undef @g_cov;

}



## -------------------------------------------------------
## Numeric sort array in ascending order and return order
## Array can contain the same number more than once
## USAGE:
## ($sa,$I)=numsortascend(@arr);
## @arr = array of numbers (int or float)
## $sa = reference to sorted array (retrieve as @$sa)
## $I = reference to sorted indices (retrieve as @$I)
## -------------------------------------------------------
sub numsortascend {
  my @array=@_;  ## input is an array
  my %ind=();    ## set up a hash
  
  for (my $j=0; $j<scalar(@array); $j++)   ## loop through the array 
  {
    #if ($array[$j] !~ /^[+-]?\d+\.?\d*$/ ) { die("this element of the input array does not look like a number: $array[$j]\nQuitting...\n"); }
    push(@{$ind{$array[$j]}},$j); 
  }

  my @sortedarray = sort {$a <=> $b} @array;
  my @sortedind=();
  
  for (my $j=0; $j<scalar(@sortedarray); $j++) 
  {
    push(@sortedind,shift(@{$ind{$sortedarray[$j]}} ));
  }
  
  return (\@sortedarray,\@sortedind);
}
## -------------------------------------------------------


## -------------------------------------------------------
## Numeric sort array in descending order and return order
## Array can contain the same number more than once
## USAGE:
## ($sa,$I)=numsortdescend(@arr);
## @arr = array of numbers (int or float)
## $sa = reference to sorted array (retrieve as @$sa)
## $I = reference to sorted indices (retrieve as @$I)
## -------------------------------------------------------
sub numsortdescend {
  my @array=@_;

  my %ind=();
  for (my $j=0; $j<scalar(@array); $j++) {
    #if ($array[$j] !~ /^[+-]?\d+\.?\d*$/ ) { die("this element of the input array does not look like a number: $array[$j]\nQuitting...\n"); }
    push(@{$ind{$array[$j]}},$j);
  }

  my @sortedarray = sort {$b <=> $a} @array;
  my @sortedind=();
  for (my $j=0; $j<scalar(@sortedarray); $j++) {
    push(@sortedind,shift(@{$ind{$sortedarray[$j]}} ));
  }
  return (\@sortedarray,\@sortedind);
}
# -------------------------------------------------------


## ------------------------------------------------
## Re-arrange elements of array in specified order
## NOTE:
## array can contain either numbers or strings
## USAGE:
## @newarray = putarrayinorder($ref_arr,$ref_I)
## $ref_arr = reference to the original array
## $ref_I = reference to the array of indices
## @newarray = re-arranged array
## ------------------------------------------------
sub putarrayinorder {
  my ($ref_arr,$ref_I)=@_;
  my @array=@$ref_arr; my @I=@$ref_I;
  if (scalar(@array)!=scalar(@I)) { die("arrays of elements and indices have different sizes!"); }
  my @newarray=();
  for(my $j=0; $j<scalar(@I); $j++) { push(@newarray,$array[$I[$j]]); }
  return @newarray;
}
# ------------------------------------------------




